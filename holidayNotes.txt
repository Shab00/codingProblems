 Saudi - Nov - 2025

# Level Order Traversal (Medium)

Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

Example 1:

Input: root = [3,9,20,null,null,15,7]  
Output: [[3],[9,20],[15,7]]

Tree:
```
    3
   / \
  9  20
     / \
    15  7
```

Example 2:

Input: root = [1]  
Output: [[1]]

Tree:
```
1
```

Example 3:

Input: root = []  
Output: []

Tree:
```
(empty)
```

Constraints:

- The number of nodes in the tree is in the range [0, 2000].
- -1000 <= Node.val <= 1000

---

# Binary Tree Right Side View

You are given the root of a binary tree. Return only the values of the nodes that are visible from the right side of the tree, ordered from top to bottom.

Example 1:

Input: root = [1,2,3]  
Output: [1,3]

Tree:
```
  1
 / \
2   3
```

Example 2:

Input: root = [1,2,3,4,5,6,7]  
Output: [1,3,7]

Tree:
```
       1
     /   \
    2     3
   / \   / \
  4  5  6  7
```

Constraints:

- 0 <= number of nodes in the tree <= 100
- -100 <= Node.val <= 100

 ---

 Greece - Sep - 2025

# Time-Based Key-Value Store (Binary Search Version)

Design a **time-based key-value data structure** that can store multiple values for the same key at different timestamps, and retrieve the key's value as of a specific timestamp.

**Implement a `TimeMap` class with the following operations:**

- `TimeMap()`: Initializes the data structure.
- `void set(String key, String value, int timestamp)`: Stores the key `key` with the value `value` at the given `timestamp`.
- `String get(String key, int timestamp)`: Retrieves the value for `key` with the largest timestamp `<= timestamp`.  
  - If there are multiple such values, return the one with the largest timestamp.
  - If no suitable value exists, return the empty string `""`.

### Example Usage

**Input:**
```
["TimeMap", "set", "get", "get", "set", "get", "get"]
[[], ["foo", "bar", 1], ["foo", 1], ["foo", 3], ["foo", "bar2", 4], ["foo", 4], ["foo", 5]]
```

**Output:**
```
[null, null, "bar", "bar", null, "bar2", "bar2"]
```

**Explanation:**
- `TimeMap timeMap = new TimeMap();`
- `timeMap.set("foo", "bar", 1);` → Stores "foo" = "bar" at timestamp 1.
- `timeMap.get("foo", 1);` → Returns "bar".
- `timeMap.get("foo", 3);` → Returns "bar" (latest value before or at timestamp 3 is at timestamp 1).
- `timeMap.set("foo", "bar2", 4);` → Stores "foo" = "bar2" at timestamp 4.
- `timeMap.get("foo", 4);` → Returns "bar2".
- `timeMap.get("foo", 5);` → Returns "bar2" (latest value before or at timestamp 5 is at timestamp 4).

---

**Note:**  
- The key challenge is efficiently retrieving the correct value for a given timestamp, likely using **binary search** over stored timestamps per key.
- Store each key's values and timestamps so you can quickly look up the correct value.

class TimeMap:

    def __init__(self):
        

    def set(self, key: str, value: str, timestamp: int) -> None:
        

    def get(self, key: str, timestamp: int) -> str:
        


# Your TimeMap object will be instantiated and called as such:
# obj = TimeMap()
# obj.set(key,value,timestamp)
# param_2 = obj.get(key,timestamp)

---

# Best Time to Buy and Sell Stock

**Problem Statement:**

Given an integer array `prices` where `prices[i]` is the price of NeetCoin on the ith day,  
choose a single day to buy one NeetCoin and a different day in the future to sell it.  
Return the maximum profit you can achieve. If no transaction yields profit, return `0`.

**Examples:**

- Input: `prices = [10,1,5,6,7,1]`  
  Output: `6`  
  Explanation: Buy on day 1 (`1`), sell on day 4 (`7`): `7 - 1 = 6`.

- Input: `prices = [10,8,7,5,2]`  
  Output: `0`  
  Explanation: No profitable transaction is possible.

**Constraints:**
- `1 <= prices.length <= 100`
- `0 <= prices[i] <= 100`

---

# Longest Repeating Character Replacement

u are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

Examples:

Example 1:
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.

Example 2:
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exist other ways to achieve this answer too.

Constraints:
- 1 <= s.length <= 10^5
- s consists of only uppercase English letters.
- 0 <= k <= s.length
